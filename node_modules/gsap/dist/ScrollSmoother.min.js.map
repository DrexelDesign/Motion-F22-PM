{"version":3,"file":"ScrollSmoother.min.js","sources":["../src/ScrollSmoother.js"],"sourcesContent":["/*!\n * ScrollSmoother 3.11.3\n * https://greensock.com\n *\n * @license Copyright 2008-2022, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _toArray, _clamp, ScrollTrigger, _mainInstance, _expo, _getVelocityProp, _inputObserver, _context, _onResizeDelayedCall,\n\t_windowExists = () => typeof(window) !== \"undefined\",\n\t_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),\n\t_bonusValidated = 1, //<name>ScrollSmoother</name>\n\t_isViewport = e => !!~_root.indexOf(e),\n\t_getTime = Date.now,\n\t_round = value => Math.round(value * 100000) / 100000 || 0,\n\t_autoDistance = (el, progress) => { // for calculating the distance (and offset) for elements with speed: \"auto\". Progress is for if it's \"above the fold\" (negative start position), so we can crop as little as possible.\n\t\tlet parent = el.parentNode || _docEl,\n\t\t\tb1 = el.getBoundingClientRect(),\n\t\t\tb2 = parent.getBoundingClientRect(),\n\t\t\tgapTop = b2.top - b1.top,\n\t\t\tgapBottom = b2.bottom - b1.bottom,\n\t\t\tchange = (Math.abs(gapTop) > Math.abs(gapBottom) ? gapTop : gapBottom) / (1 - progress),\n\t\t\toffset = -change * progress,\n\t\t\tratio, extraChange;\n\t\tif (change > 0) { // if the image starts at the BOTTOM of the container, adjust things so that it shows as much of the image as possible while still covering.\n\t\t\tratio = b2.height / (_win.innerHeight + b2.height);\n\t\t\textraChange = ratio === 0.5 ? b2.height * 2 : Math.min(b2.height, -change * ratio / (2 * ratio - 1)) * 2 * (progress || 1);\n\t\t\toffset += progress ? -extraChange * progress : -extraChange / 2; // whatever the offset, we must double that in the opposite direction to compensate.\n\t\t\tchange += extraChange;\n\t\t}\n\t\treturn {change, offset};\n\t},\n\t_wrap = el => {\n\t\tlet wrapper = _doc.querySelector(\".ScrollSmoother-wrapper\"); // some frameworks load multiple times, so one already exists, just use that to avoid duplicates\n\t\tif (!wrapper) {\n\t\t\twrapper = _doc.createElement(\"div\");\n\t\t\twrapper.classList.add(\"ScrollSmoother-wrapper\");\n\t\t\tel.parentNode.insertBefore(wrapper, el);\n\t\t\twrapper.appendChild(el);\n\t\t}\n\t\treturn wrapper;\n\t};\n\nexport class ScrollSmoother {\n\n\tconstructor(vars) {\n\t\t_coreInitted || ScrollSmoother.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollSmoother)\");\n\t\tvars = this.vars = vars || {};\n\n\t\t_mainInstance && _mainInstance.kill();\n\t\t_mainInstance = this;\n\t\t_context(this);\n\n\t\tlet {smoothTouch, onUpdate, onStop, smooth, onFocusIn, normalizeScroll} = vars,\n\t\t\tcontent, wrapper, height, mainST, effects, sections, intervalID, wrapperCSS, contentCSS, paused, pausedNormalizer, recordedRefreshScroll, recordedRefreshScrub,\n\t\t\tself = this,\n\t\t\tresizeObserver = typeof(ResizeObserver) !== \"undefined\" && vars.autoResize !== false && new ResizeObserver(() => ScrollTrigger.isRefreshing || _onResizeDelayedCall.restart(true)),\n\t\t\teffectsPrefix = vars.effectsPrefix || \"\",\n\t\t\tscrollFunc = ScrollTrigger.getScrollFunc(_win),\n\t\t\tsmoothDuration = ScrollTrigger.isTouch === 1 ? (smoothTouch === true ? 0.8 : parseFloat(smoothTouch) || 0) : (smooth === 0 || smooth === false) ? 0 : parseFloat(smooth) || 0.8,\n\t\t\tcurrentY = 0,\n\t\t\tdelta = 0,\n\t\t\tstartupPhase = 1,\n\t\t\ttracker = _getVelocityProp(0),\n\t\t\tupdateVelocity = () => tracker.update(-currentY),\n\t\t\tscroll = {y: 0},\n\t\t\tremoveScroll = () => content.style.overflow = \"visible\",\n\t\t\tisProxyScrolling,\n\t\t\tkillScrub = trigger => {\n\t\t\t\ttrigger.update(); // it's possible that it hasn't been synchronized with the actual scroll position yet, like if it's later in the _triggers Array. If it was already updated, it'll skip the processing anyway.\n\t\t\t\tlet scrub = trigger.getTween();\n\t\t\t\tif (scrub) {\n\t\t\t\t\tscrub.pause();\n\t\t\t\t\tscrub._time = scrub._dur; // force the playhead to completion without rendering just so that when it resumes, it doesn't jump back in the .resetTo().\n\t\t\t\t\tscrub._tTime = scrub._tDur;\n\t\t\t\t}\n\t\t\t\tisProxyScrolling = false;\n\t\t\t\ttrigger.animation.progress(trigger.progress, true);\n\t\t\t},\n\t\t\trender = (y, force) => {\n\t\t\t\tif ((y !== currentY && !paused) || force) {\n\t\t\t\t\tif (smoothDuration) {\n\t\t\t\t\t\tcontent.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\n\t\t\t\t\t\t//content.style.transform = \"translateY(\" + y + \"px)\"; // NOTE: when we used matrix3d() or set will-change: transform, it performed noticeably worse on iOS counter-intuitively!\n\t\t\t\t\t\tcontent._gsap.y = y + \"px\";\n\t\t\t\t\t}\n\t\t\t\t\tdelta = y - currentY;\n\t\t\t\t\tcurrentY = y;\n\t\t\t\t\tScrollTrigger.isUpdating || ScrollTrigger.update();\n\t\t\t\t}\n\t\t\t},\n\t\t\tscrollTop = function(value) {\n\t\t\t\tif (arguments.length) {\n\t\t\t\t\t(value < 0) && (value = 0);\n\t\t\t\t\tscroll.y = -value; // don't use currentY because we must accurately track the delta variable (in render() method)\n\t\t\t\t\tisProxyScrolling = true; // otherwise, if snapping was applied (or anything that attempted to SET the scroll proxy's scroll position), we'd set the scroll here which would then (on the next tick) update the content tween/ScrollTrigger which would try to smoothly animate to that new value, thus the scrub tween would impede the progress. So we use this flag to respond accordingly in the ScrollTrigger's onUpdate and effectively force the scrub to its end immediately.\n\t\t\t\t\tpaused ? (currentY = -value) : render(-value);\n\t\t\t\t\tScrollTrigger.isRefreshing ? mainST.update() : scrollFunc(value); // during a refresh, we revert all scrollers to 0 and then put them back. We shouldn't force the window to that value too during the refresh.\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\treturn -currentY;\n\t\t\t},\n\t\t\tlastFocusElement, // if the user clicks a button that scrolls the page, for example, then unfocuses the window and comes back and activates the window/tab again, it'll want to focus back on that same button element but in that case we should skip it. Only jump there when a new element gets focus, like tabbing for accessibility.\n\t\t\t_onFocusIn = e => { // when the focus changes, make sure that element is on-screen\n\t\t\t\twrapper.scrollTop = 0;\n\t\t\t\tif ((e.target.contains && e.target.contains(wrapper)) || (onFocusIn && onFocusIn(this, e) === false)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tScrollTrigger.isInViewport(e.target) || (e.target === lastFocusElement) ||  this.scrollTo(e.target, false, \"center center\");\n\t\t\t\tlastFocusElement = e.target;\n\t\t\t},\n\t\t\tadjustParallaxPosition = (triggers, createdAfterEffectWasApplied) => {\n\t\t\t\tlet pins, start, dif, markers;\n\t\t\t\teffects.forEach(st => {\n\t\t\t\t\tpins = st.pins;\n\t\t\t\t\tmarkers = st.markers;\n\t\t\t\t\ttriggers.forEach(trig => {\n\t\t\t\t\t\tif (st.trigger && trig.trigger && st !== trig && (trig.trigger === st.trigger || trig.pinnedContainer === st.trigger || st.trigger.contains(trig.trigger))) {\n\t\t\t\t\t\t\tstart = trig.start;\n\t\t\t\t\t\t\tdif = (start - st.start - st.offset) / st.ratio - (start - st.start);\n\t\t\t\t\t\t\t// createdAfterEffectWasApplied && (dif -= (gsap.getProperty(st.trigger, \"y\") - st.startY) / st.ratio); // the effect applied a y offset, so if the ScrollTrigger was created after that, it'll be based on that position so we must compensate. Later we added code to ScrollTrigger to roll back in this situation anyway, so this isn't necessary. Saving it in case a situation arises where it comes in handy.\n\t\t\t\t\t\t\tpins.forEach(p => dif -= p.distance / st.ratio - p.distance);\n\t\t\t\t\t\t\ttrig.setPositions(start + dif, trig.end + dif);\n\t\t\t\t\t\t\ttrig.markerStart && markers.push(gsap.quickSetter([trig.markerStart, trig.markerEnd], \"y\", \"px\"));\n\t\t\t\t\t\t\tif (trig.pin && trig.end > 0) {\n\t\t\t\t\t\t\t\tdif = trig.end - trig.start;\n\t\t\t\t\t\t\t\tpins.push({start: trig.start, end: trig.end, distance: dif, trig: trig});\n\t\t\t\t\t\t\t\tst.setPositions(st.start, st.end + dif);\n\t\t\t\t\t\t\t\tst.vars.onRefresh(st);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tonRefresh = () => {\n\t\t\t\tremoveScroll();\n\t\t\t\trequestAnimationFrame(removeScroll);\n\t\t\t\tif (effects) { // adjust all the effect start/end positions including any pins!\n\t\t\t\t\teffects.forEach(st => {\n\t\t\t\t\t\tlet start = st.start,\n\t\t\t\t\t\t\tend = st.auto ? Math.min(ScrollTrigger.maxScroll(st.scroller), st.end) : start + (st.end - start) / st.ratio,\n\t\t\t\t\t\t\toffset = (end - st.end) / 2; // we split the difference so that it reaches its natural position in the MIDDLE of the viewport\n\t\t\t\t\t\tstart -= offset;\n\t\t\t\t\t\tend -= offset;\n\t\t\t\t\t\tst.offset = offset || 0.0001; // we assign at least a tiny value because we check in the onUpdate for .offset being set in order to apply values.\n\t\t\t\t\t\tst.pins.length = 0;\n\t\t\t\t\t\tst.setPositions(Math.min(start, end), Math.max(start, end));\n\t\t\t\t\t\tst.vars.onRefresh(st);\n\t\t\t\t\t});\n\t\t\t\t\tadjustParallaxPosition(ScrollTrigger.sort());\n\t\t\t\t}\n\t\t\t\ttracker.reset();\n\t\t\t},\n\t\t\taddOnRefresh = () => ScrollTrigger.addEventListener(\"refresh\", onRefresh),\n\t\t\trestoreEffects = () => effects && effects.forEach(st => st.vars.onRefresh(st)),\n\t\t\trevertEffects = () => {\n\t\t\t\teffects && effects.forEach(st => st.vars.onRefreshInit(st));\n\t\t\t\treturn restoreEffects;\n\t\t\t},\n\t\t\teffectValueGetter = (name, value, index, el) => {\n\t\t\t\treturn () => {\n\t\t\t\t\tlet v = typeof(value) === \"function\" ? value(index, el) : value;\n\t\t\t\t\tv || v === 0 || (v = el.getAttribute(\"data-\" + effectsPrefix + name) || (name === \"speed\" ? 1 : 0));\n\t\t\t\t\tel.setAttribute(\"data-\" + effectsPrefix + name, v);\n\t\t\t\t\treturn v === \"auto\" ? v : parseFloat(v);\n\t\t\t\t};\n\t\t\t},\n\t\t\tcreateEffect = (el, speed, lag, index) => {\n\t\t\t\tlet getSpeed = effectValueGetter(\"speed\", speed, index, el),\n\t\t\t\t\tgetLag = effectValueGetter(\"lag\", lag, index, el),\n\t\t\t\t\tstartY = gsap.getProperty(el, \"y\"),\n\t\t\t\t\tcache = el._gsap,\n\t\t\t\t\tratio, st, autoSpeed, scrub, progressOffset, yOffset,\n\t\t\t\t\tinitDynamicValues = () => {\n\t\t\t\t\t\tspeed = getSpeed();\n\t\t\t\t\t\tlag = getLag();\n\t\t\t\t\t\tratio = parseFloat(speed) || 1;\n\t\t\t\t\t\tautoSpeed = speed === \"auto\";\n\t\t\t\t\t\tprogressOffset = autoSpeed ? 0 : 0.5;\n\t\t\t\t\t\tscrub && scrub.kill();\n\t\t\t\t\t\tscrub = lag && gsap.to(el, {ease: _expo, overwrite: false, y: \"+=0\", duration: lag});\n\t\t\t\t\t\tif (st) {\n\t\t\t\t\t\t\tst.ratio = ratio;\n\t\t\t\t\t\t\tst.autoSpeed = autoSpeed;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\trevert = () => {\n\t\t\t\t\t\tcache.y = startY + \"px\";\n\t\t\t\t\t\tcache.renderTransform(1);\n\t\t\t\t\t\tinitDynamicValues();\n\t\t\t\t\t},\n\t\t\t\t\tpins = [],\n\t\t\t\t\tmarkers = [],\n\t\t\t\t\tchange = 0,\n\t\t\t\t\tupdateChange = self => {\n\t\t\t\t\t\tif (autoSpeed) {\n\t\t\t\t\t\t\trevert();\n\t\t\t\t\t\t\tlet auto = _autoDistance(el, _clamp(0, 1, -self.start / (self.end - self.start)));\n\t\t\t\t\t\t\tchange = auto.change;\n\t\t\t\t\t\t\tyOffset = auto.offset;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchange = (self.end - self.start) * (1 - ratio);\n\t\t\t\t\t\t\tyOffset = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpins.forEach(p => change -= p.distance * (1 - ratio));\n\t\t\t\t\t\tself.vars.onUpdate(self);\n\t\t\t\t\t\tscrub && scrub.progress(1);\n\t\t\t\t\t};\n\t\t\t\tinitDynamicValues();\n\t\t\t\tif (ratio !== 1 || autoSpeed || scrub) {\n\t\t\t\t\tst = ScrollTrigger.create({\n\t\t\t\t\t\ttrigger: autoSpeed ? el.parentNode : el,\n\t\t\t\t\t\tscroller: wrapper,\n\t\t\t\t\t\tscrub: true,\n\t\t\t\t\t\trefreshPriority: -999, // must update AFTER any other ScrollTrigger pins\n\t\t\t\t\t\tonRefreshInit: revert,\n\t\t\t\t\t\tonRefresh: updateChange,\n\t\t\t\t\t\tonKill: self => {\n\t\t\t\t\t\t\tlet i = effects.indexOf(self);\n\t\t\t\t\t\t\ti >= 0 && effects.splice(i, 1);\n\t\t\t\t\t\t\trevert();\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonUpdate: self => {\n\t\t\t\t\t\t\tlet y = startY + change * (self.progress - progressOffset),\n\t\t\t\t\t\t\t\ti = pins.length,\n\t\t\t\t\t\t\t\textraY = 0,\n\t\t\t\t\t\t\t\tpin, scrollY, end;\n\t\t\t\t\t\t\tif (self.offset) { // wait until the effects are adjusted.\n\t\t\t\t\t\t\t\tif (i) { // pinning must be handled in a special way because when pinned, slope changes to 1.\n\t\t\t\t\t\t\t\t\tscrollY = -currentY; // -scroll.y;\n\t\t\t\t\t\t\t\t\tend = self.end;\n\t\t\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\t\t\tpin = pins[i];\n\t\t\t\t\t\t\t\t\t\tif (pin.trig.isActive || (scrollY >= pin.start && scrollY <= pin.end)) { // currently pinned so no need to set anything\n\t\t\t\t\t\t\t\t\t\t\tif (scrub) {\n\t\t\t\t\t\t\t\t\t\t\t\tpin.trig.progress += pin.trig.direction < 0 ? 0.001 : -0.001; // just to make absolutely sure that it renders (if the progress didn't change, it'll skip)\n\t\t\t\t\t\t\t\t\t\t\t\tpin.trig.update(0, 0, 1);\n\t\t\t\t\t\t\t\t\t\t\t\tscrub.resetTo(\"y\", parseFloat(cache.y), -delta, true);\n\t\t\t\t\t\t\t\t\t\t\t\tstartupPhase && scrub.progress(1);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t(scrollY > pin.end) && (extraY += pin.distance);\n\t\t\t\t\t\t\t\t\t\tend -= pin.distance;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ty = startY + extraY + change * (((gsap.utils.clamp(self.start, self.end, scrollY) - self.start - extraY) / (end - self.start)) - progressOffset);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ty = _round(y + yOffset);\n\t\t\t\t\t\t\t\tmarkers.length && !autoSpeed && markers.forEach(setter => setter(y - extraY));\n\t\t\t\t\t\t\t\tif (scrub) {\n\t\t\t\t\t\t\t\t\tscrub.resetTo(\"y\", y, -delta, true);\n\t\t\t\t\t\t\t\t\tstartupPhase && scrub.progress(1);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcache.y = y + \"px\";\n\t\t\t\t\t\t\t\t\tcache.renderTransform(1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tupdateChange(st);\n\t\t\t\t\tgsap.core.getCache(st.trigger).stRevert = revertEffects; // if user calls ScrollSmoother.create() with effects and THEN creates a ScrollTrigger on the same trigger element, the effect would throw off the start/end positions thus we needed a way to revert things when creating a new ScrollTrigger in that scenario, so we use this stRevert property of the GSCache inside ScrollTrigger.\n\t\t\t\t\tst.startY = startY;\n\t\t\t\t\tst.pins = pins;\n\t\t\t\t\tst.markers = markers;\n\t\t\t\t\tst.ratio = ratio;\n\t\t\t\t\tst.autoSpeed = autoSpeed;\n\t\t\t\t\tel.style.willChange = \"transform\";\n\t\t\t\t}\n\t\t\t\treturn st;\n\t\t\t};\n\n\t\taddOnRefresh();\n\t\tScrollTrigger.addEventListener(\"killAll\", addOnRefresh);\n\t\tgsap.delayedCall(0.5, () => startupPhase = 0);\n\n\t\tthis.scrollTop = scrollTop;\n\n\t\tthis.scrollTo = (target, smooth, position) => {\n\t\t\tlet p = gsap.utils.clamp(0, ScrollTrigger.maxScroll(_win), isNaN(target) ? this.offset(target, position) : +target);\n\t\t\t!smooth ? scrollTop(p) : paused ? gsap.to(this, {duration: smoothDuration, scrollTop: p, overwrite: \"auto\", ease: _expo}) : scrollFunc(p);\n\t\t};\n\n\t\tthis.offset = (target, position) => {\n\t\t\ttarget = _toArray(target)[0];\n\t\t\tlet cssText = target.style.cssText, // because if there's an effect applied, we revert(). We need to restore.\n\t\t\t\tst = ScrollTrigger.create({trigger: target, start: position || \"top top\"}),\n\t\t\t\ty;\n\t\t\teffects && adjustParallaxPosition([st], true);\n\t\t\ty = st.start;\n\t\t\tst.kill(false);\n\t\t\ttarget.style.cssText = cssText;\n\t\t\tgsap.core.getCache(target).uncache = 1;\n\t\t\treturn y;\n\t\t};\n\n\t\tfunction refreshHeight() {\n\t\t\theight = content.clientHeight;\n\t\t\tcontent.style.overflow = \"visible\"\n\t\t\t_body.style.height = height + \"px\";\n\t\t\treturn height - _win.innerHeight;\n\t\t}\n\n\t\tthis.content = function(element) {\n\t\t\tif (arguments.length) {\n\t\t\t\tlet newContent = _toArray(element || \"#smooth-content\")[0] || console.warn(\"ScrollSmoother needs a valid content element.\") || _body.children[0];\n\t\t\t\tif (newContent !== content) {\n\t\t\t\t\tcontent = newContent;\n\t\t\t\t\tcontentCSS = content.getAttribute(\"style\") || \"\";\n\t\t\t\t\tresizeObserver && resizeObserver.observe(content);\n\t\t\t\t\tgsap.set(content, {overflow: \"visible\", width: \"100%\", boxSizing: \"border-box\", y: \"+=0\"});\n\t\t\t\t\tsmoothDuration || gsap.set(content, {clearProps: \"transform\"});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn content;\n\t\t}\n\n\t\tthis.wrapper = function(element) {\n\t\t\tif (arguments.length) {\n\t\t\t\twrapper = _toArray(element || \"#smooth-wrapper\")[0] || _wrap(content);\n\t\t\t\twrapperCSS = wrapper.getAttribute(\"style\") || \"\";\n\t\t\t\trefreshHeight();\n\t\t\t\tgsap.set(wrapper, smoothDuration ? {overflow: \"hidden\", position: \"fixed\", height: \"100%\", width: \"100%\", top: 0, left: 0, right: 0, bottom: 0} : {overflow: \"visible\", position: \"relative\", width: \"100%\", height: \"auto\", top: \"auto\", bottom: \"auto\", left: \"auto\", right: \"auto\"});\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn wrapper;\n\t\t}\n\n\t\tthis.effects = (targets, config) => {\n\t\t\teffects || (effects = []);\n\t\t\tif (!targets) {\n\t\t\t\treturn effects.slice(0);\n\t\t\t}\n\t\t\ttargets = _toArray(targets);\n\t\t\ttargets.forEach(target => {\n\t\t\t\tlet i = effects.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\teffects[i].trigger === target && effects[i].kill(); // will automatically splice() it from the effects Array in the onKill\n\t\t\t\t}\n\t\t\t});\n\t\t\tconfig = config || {};\n\t\t\tlet {speed, lag} = config,\n\t\t\t\teffectsToAdd = [],\n\t\t\t\ti, st;\n\t\t\tfor (i = 0; i < targets.length; i++) {\n\t\t\t\tst = createEffect(targets[i], speed, lag, i);\n\t\t\t\tst && effectsToAdd.push(st);\n\t\t\t}\n\t\t\teffects.push(...effectsToAdd);\n\t\t\treturn effectsToAdd;\n\t\t};\n\n\t\tthis.sections = (targets, config) => {\n\t\t\tsections || (sections = []);\n\t\t\tif (!targets) {\n\t\t\t\treturn sections.slice(0);\n\t\t\t}\n\t\t\tlet newSections = _toArray(targets).map(el => ScrollTrigger.create({\n\t\t\t\t\ttrigger: el,\n\t\t\t\t\tstart: \"top 120%\",\n\t\t\t\t\tend: \"bottom -20%\",\n\t\t\t\t\tonToggle: self => {\n\t\t\t\t\t\tel.style.opacity = self.isActive ? \"1\" : \"0\";\n\t\t\t\t\t\tel.style.pointerEvents = self.isActive ? \"all\" : \"none\";\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t\tconfig && config.add ? sections.push(...newSections) : (sections = newSections.slice(0));\n\t\t\treturn newSections;\n\t\t}\n\n\t\tthis.content(vars.content);\n\t\tthis.wrapper(vars.wrapper);\n\t\tthis.render = y => render(y || y === 0 ? y : currentY);\n\t\tthis.getVelocity = () => tracker.getVelocity(-currentY);\n\n\t\tScrollTrigger.scrollerProxy(wrapper, {\n\t\t\tscrollTop: scrollTop,\n\t\t\tscrollHeight: () => refreshHeight() && _body.scrollHeight,\n\t\t\tfixedMarkers: vars.fixedMarkers !== false && !!smoothDuration,\n\t\t\tcontent: content,\n\t\t\tgetBoundingClientRect() {\n\t\t\t\treturn {top: 0, left: 0, width: _win.innerWidth, height: _win.innerHeight};\n\t\t\t}\n\t\t});\n\t\tScrollTrigger.defaults({scroller: wrapper});\n\t\tlet existingScrollTriggers = ScrollTrigger.getAll().filter(st => st.scroller === _win || st.scroller === wrapper);\n\t\texistingScrollTriggers.forEach(st => st.revert(true)) // in case it's in an environment like React where child components that have ScrollTriggers instantiate BEFORE the parent that does ScrollSmoother.create(...);\n\n\t\tmainST = ScrollTrigger.create({\n\t\t\tanimation: gsap.fromTo(scroll, {y: 0}, {\n\t\t\t\ty: () => -refreshHeight(),\n\t\t\t\timmediateRender: false,\n\t\t\t\tease: \"none\",\n\t\t\t\tdata: \"ScrollSmoother\",\n\t\t\t\tduration: 100, // for added precision\n\t\t\t\tonUpdate: function() {\n\t\t\t\t\tif (this._dur) { // skip when it's the \"from\" part of the tween (setting the startAt)\n\t\t\t\t\t\tlet force = isProxyScrolling;\n\t\t\t\t\t\tif (force) {\n\t\t\t\t\t\t\tkillScrub(mainST);\n\t\t\t\t\t\t\tscroll.y = currentY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trender(scroll.y, force);\n\t\t\t\t\t\tupdateVelocity();\n\t\t\t\t\t\tonUpdate && !paused && onUpdate(self);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}),\n\t\t\tonRefreshInit: self => {\n\t\t\t\tif (effects) {\n\t\t\t\t\tlet pins = ScrollTrigger.getAll().filter(st => !!st.pin);\n\t\t\t\t\teffects.forEach(st => {\n\t\t\t\t\t\tif (!st.vars.pinnedContainer) {\n\t\t\t\t\t\t\tpins.forEach(pinST => {\n\t\t\t\t\t\t\t\tif (pinST.pin.contains(st.trigger)) {\n\t\t\t\t\t\t\t\t\tlet v = st.vars;\n\t\t\t\t\t\t\t\t\tv.pinnedContainer = pinST.pin;\n\t\t\t\t\t\t\t\t\tst.vars = null; // otherwise, it'll self.kill(), triggering the onKill()\n\t\t\t\t\t\t\t\t\tst.init(v, st.animation);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tlet scrub = self.getTween();\n\t\t\t\trecordedRefreshScrub = scrub && scrub._end > scrub._dp._time; // don't use scrub.progress() < 1 because we may have called killScrub() recently in which case it'll report progress() as 1 when we were actually in the middle of a scrub. That's why we tap into the _end instead.\n\t\t\t\trecordedRefreshScroll = currentY;\n\t\t\t\tscroll.y = 0;\n\t\t\t\tif (smoothDuration) { // Safari 16 has a major bug - if you set wrapper.scrollTop to 0 (even if it's already 0), it blocks the whole page from scrolling page non-scrollable! See https://bugs.webkit.org/show_bug.cgi?id=245300 and https://codepen.io/GreenSock/pen/YzLZVOz An alternate is to set position to absolute and then back to fixed after setting scrollTop, but that's less performant.\n\t\t\t\t\twrapper.style.pointerEvents = \"none\"; // Safari 16 has a major bug - if you set wrapper.scrollTop to 0 (even if it's already 0), it makes the entire page non-scrollable! The only workaround I know of is to change to position absolute and then back again. See https://bugs.webkit.org/show_bug.cgi?id=245300 and https://codepen.io/GreenSock/pen/YzLZVOz\n\t\t\t\t\twrapper.scrollTop = 0; // set wrapper.scrollTop to 0 because in some very rare situations, the browser will auto-set that, like if there's a hash in the link or changing focus to an off-screen input\n\t\t\t\t\tsetTimeout(() => wrapper.style.removeProperty(\"pointer-events\"), 50);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonRefresh: self => {\n\t\t\t\tself.animation.invalidate(); // because pinnedContainers may have been found in ScrollTrigger's _refreshAll() that extend the height. Without this, it may prevent the user from being able to scroll all the way down.\n\t\t\t\tself.setPositions(self.start, refreshHeight());\n\t\t\t\trecordedRefreshScrub || killScrub(self);\n\t\t\t\tscroll.y = -scrollFunc(); // in 3.11.1, we shifted to forcing the scroll position to 0 during the entire refreshAll() in ScrollTrigger and then restored the scroll position AFTER everything had been updated, thus we should always make these adjustments AFTER a full refresh rather than putting it in the onRefresh() of the individual mainST ScrollTrigger which would fire before the scroll position was restored.\n\t\t\t\trender(scroll.y);\n\t\t\t\tstartupPhase || self.animation.progress(gsap.utils.clamp(0, 1, recordedRefreshScroll / -self.end));\n\t\t\t\tif (recordedRefreshScrub) { // we need to trigger the scrub to happen again\n\t\t\t\t\tself.progress -= 0.001;\n\t\t\t\t\tself.update();\n\t\t\t\t}\n\t\t\t},\n\t\t\tid: \"ScrollSmoother\",\n\t\t\tscroller: _win,\n\t\t\tinvalidateOnRefresh: true,\n\t\t\tstart: 0,\n\t\t\trefreshPriority: -9999, // because all other pins, etc. should be calculated first before this figures out the height of the body. BUT this should also update FIRST so that the scroll position on the proxy is up-to-date when all the ScrollTriggers calculate their progress! -9999 is a special number that ScrollTrigger looks for to handle in this way.\n\t\t\tend: refreshHeight,\n\t\t\tonScrubComplete: () => {\n\t\t\t\ttracker.reset();\n\t\t\t\tonStop && onStop(this);\n\t\t\t},\n\t\t\tscrub: smoothDuration || true,\n\t\t});\n\n\t\tthis.smooth = function(value) {\n\t\t\targuments.length && (smoothDuration = value || 0);\n\t\t\treturn arguments.length ? mainST.scrubDuration(value) : mainST.getTween() ? mainST.getTween().duration() : 0;\n\t\t};\n\n\t\tmainST.getTween() && (mainST.getTween().vars.ease = vars.ease || _expo);\n\n\t\tthis.scrollTrigger = mainST;\n\n\t\tvars.effects && this.effects(vars.effects === true ? \"[data-\" + effectsPrefix + \"speed], [data-\" + effectsPrefix + \"lag]\" : vars.effects, {});\n\t\tvars.sections && this.sections(vars.sections === true ? \"[data-section]\" : vars.sections);\n\n\t\texistingScrollTriggers.forEach(st => {\n\t\t\tst.vars.scroller = wrapper;\n\t\t\tst.init(st.vars, st.animation);\n\t\t});\n\n\t\tthis.paused = function(value, allowNestedScroll) {\n\t\t\tif (arguments.length) {\n\t\t\t\tif (!!paused !== value) {\n\t\t\t\t\tif (value) { // pause\n\t\t\t\t\t\tmainST.getTween() && mainST.getTween().pause();\n\t\t\t\t\t\tscrollFunc(-currentY);\n\t\t\t\t\t\ttracker.reset();\n\t\t\t\t\t\tpausedNormalizer = ScrollTrigger.normalizeScroll();\n\t\t\t\t\t\tpausedNormalizer && pausedNormalizer.disable(); // otherwise the normalizer would try to scroll the page on things like wheel events.\n\t\t\t\t\t\tpaused = ScrollTrigger.observe({\n\t\t\t\t\t\t\tpreventDefault: true,\n\t\t\t\t\t\t\ttype: \"wheel,touch,scroll\",\n\t\t\t\t\t\t\tdebounce: false,\n\t\t\t\t\t\t\tallowClicks: true,\n\t\t\t\t\t\t\tonChangeY: () => scrollTop(-currentY) // refuse to scroll\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpaused.nested = _inputObserver(_docEl, \"wheel,touch,scroll\", true, allowNestedScroll !== false); // allow nested scrolling, like modals\n\t\t\t\t\t} else { // resume\n\t\t\t\t\t\tpaused.nested.kill();\n\t\t\t\t\t\tpaused.kill();\n\t\t\t\t\t\tpaused = 0;\n\t\t\t\t\t\tpausedNormalizer && pausedNormalizer.enable();\n\t\t\t\t\t\tmainST.progress = (-currentY - mainST.start) / (mainST.end - mainST.start);\n\t\t\t\t\t\tkillScrub(mainST);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn !!paused;\n\t\t};\n\n\t\tthis.kill = this.revert = () => {\n\t\t\tthis.paused(false);\n\t\t\tkillScrub(mainST);\n\t\t\tmainST.kill();\n\t\t\tlet triggers = (effects || []).concat(sections || []),\n\t\t\t\ti = triggers.length;\n\t\t\twhile (i--) { // make sure we go backwards because the onKill() will effects.splice(index, 1) and we don't want to skip\n\t\t\t\ttriggers[i].kill();\n\t\t\t}\n\t\t\tScrollTrigger.scrollerProxy(wrapper);\n\t\t\tScrollTrigger.removeEventListener(\"killAll\", addOnRefresh);\n\t\t\tScrollTrigger.removeEventListener(\"refresh\", onRefresh);\n\t\t\twrapper.style.cssText = wrapperCSS;\n\t\t\tcontent.style.cssText = contentCSS;\n\t\t\tlet defaults = ScrollTrigger.defaults({});\n\t\t\tdefaults && defaults.scroller === wrapper && ScrollTrigger.defaults({scroller: _win});\n\t\t\tthis.normalizer && ScrollTrigger.normalizeScroll(false);\n\t\t\tclearInterval(intervalID);\n\t\t\t_mainInstance = null;\n\t\t\tresizeObserver && resizeObserver.disconnect();\n\t\t\t_body.style.removeProperty(\"height\");\n\t\t\t_win.removeEventListener(\"focusin\", _onFocusIn);\n\t\t}\n\n\t\tthis.refresh = (soft, force) => mainST.refresh(soft, force);\n\n\t\tif (normalizeScroll) {\n\t\t\tthis.normalizer = ScrollTrigger.normalizeScroll(normalizeScroll === true ? { debounce: true, content: !smoothDuration && content } : normalizeScroll);\n\t\t}\n\n\t\tScrollTrigger.config(vars); // in case user passes in ignoreMobileResize for example\n\t\t(\"overscrollBehavior\" in _win.getComputedStyle(_body)) && gsap.set([_body, _docEl], {overscrollBehavior: \"none\"});\n\t\t(\"scrollBehavior\" in _win.getComputedStyle(_body)) && gsap.set([_body, _docEl], {scrollBehavior: \"auto\"});\n\n\t\t// if the user hits the tab key (or whatever) to shift focus to an element that's off-screen, center that element.\n\t\t_win.addEventListener(\"focusin\", _onFocusIn);\n\n\t\tintervalID = setInterval(updateVelocity, 250);\n\n\t\t_doc.readyState === \"loading\" || requestAnimationFrame(() => ScrollTrigger.refresh());\n\n\t}\n\n\tget progress() {\n\t\treturn this.scrollTrigger ? this.scrollTrigger.animation._time / 100 : 0;\n\t}\n\n\n\tstatic register(core) {\n\t\tif (!_coreInitted) {\n\t\t\tgsap = core || _getGSAP();\n\t\t\tif (_windowExists() && window.document) {\n\t\t\t\t_win = window;\n\t\t\t\t_doc = document;\n\t\t\t\t_docEl = _doc.documentElement;\n\t\t\t\t_body = _doc.body;\n\t\t\t}\n\t\t\tif (gsap) {\n\t\t\t\t_toArray = gsap.utils.toArray;\n\t\t\t\t_clamp = gsap.utils.clamp;\n\t\t\t\t_expo = gsap.parseEase(\"expo\");\n\t\t\t\t_context = gsap.core.context || function() {};\n\t\t\t\t_onResizeDelayedCall = gsap.delayedCall(0.2, () => ScrollTrigger.isRefreshing || (_mainInstance && _mainInstance.refresh())).pause();\n\t\t\t\tScrollTrigger = gsap.core.globals().ScrollTrigger;\n\t\t\t\tgsap.core.globals(\"ScrollSmoother\", ScrollSmoother); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n\t\t\t//\tgsap.ticker.lagSmoothing(50, 100); // generally people don't want things to jump (honoring smoothness over time is better with smooth scrolling)\n\t\t\t\tif (_body && ScrollTrigger) {\n\t\t\t\t\t_root = [_win, _doc, _docEl, _body];\n\t\t\t\t\t_getVelocityProp = ScrollTrigger.core._getVelocityProp;\n\t\t\t\t\t_inputObserver = ScrollTrigger.core._inputObserver;\n\t\t\t\t\tScrollSmoother.refresh = ScrollTrigger.refresh;\n\t\t\t\t\t_coreInitted = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn _coreInitted;\n\t}\n\n\n}\n\nScrollSmoother.version = \"3.11.3\";\nScrollSmoother.create = vars => (_mainInstance && vars && _mainInstance.content() === _toArray(vars.content)[0]) ? _mainInstance : new ScrollSmoother(vars);\nScrollSmoother.get = () => _mainInstance;\n\n_getGSAP() && gsap.registerPlugin(ScrollSmoother);\n\nexport { ScrollSmoother as default };"],"names":["_windowExists","window","_getGSAP","gsap","registerPlugin","_coreInitted","_win","_doc","_docEl","_body","_toArray","_clamp","ScrollTrigger","_mainInstance","_expo","_getVelocityProp","_inputObserver","_context","_onResizeDelayedCall","ScrollSmoother","register","core","document","documentElement","body","utils","toArray","clamp","parseEase","context","delayedCall","isRefreshing","refresh","pause","globals","this","scrollTrigger","animation","_time","vars","console","warn","kill","updateVelocity","tracker","update","currentY","removeScroll","content","style","overflow","killScrub","trigger","scrub","getTween","_dur","_tTime","_tDur","isProxyScrolling","progress","render","y","force","paused","smoothDuration","transform","_gsap","delta","isUpdating","scrollTop","value","arguments","length","scroll","mainST","scrollFunc","_onFocusIn","e","wrapper","target","contains","onFocusIn","_this","isInViewport","lastFocusElement","scrollTo","adjustParallaxPosition","triggers","pins","start","dif","markers","effects","forEach","st","trig","pinnedContainer","offset","ratio","p","distance","setPositions","end","markerStart","push","quickSetter","markerEnd","pin","onRefresh","requestAnimationFrame","auto","Math","min","maxScroll","scroller","max","sort","reset","addOnRefresh","addEventListener","restoreEffects","revertEffects","onRefreshInit","effectValueGetter","name","index","el","v","getAttribute","effectsPrefix","setAttribute","parseFloat","createEffect","speed","lag","initDynamicValues","getSpeed","getLag","progressOffset","autoSpeed","to","ease","overwrite","duration","revert","cache","startY","renderTransform","updateChange","self","_autoDistance","extraChange","parent","parentNode","b1","getBoundingClientRect","b2","gapTop","top","gapBottom","bottom","change","abs","height","innerHeight","yOffset","onUpdate","getProperty","create","refreshPriority","onKill","i","indexOf","splice","scrollY","extraY","isActive","direction","resetTo","startupPhase","_round","round","setter","getCache","stRevert","willChange","sections","intervalID","wrapperCSS","contentCSS","pausedNormalizer","recordedRefreshScroll","recordedRefreshScrub","smoothTouch","onStop","smooth","normalizeScroll","resizeObserver","ResizeObserver","autoResize","restart","getScrollFunc","isTouch","refreshHeight","clientHeight","position","isNaN","cssText","uncache","element","newContent","children","observe","set","width","boxSizing","clearProps","_wrap","querySelector","createElement","classList","add","insertBefore","appendChild","left","right","targets","config","slice","effectsToAdd","newSections","map","onToggle","opacity","pointerEvents","getVelocity","scrollerProxy","scrollHeight","fixedMarkers","innerWidth","defaults","existingScrollTriggers","getAll","filter","fromTo","immediateRender","data","pinST","init","_end","_dp","setTimeout","removeProperty","invalidate","id","invalidateOnRefresh","onScrubComplete","scrubDuration","allowNestedScroll","disable","preventDefault","type","debounce","allowClicks","onChangeY","nested","enable","concat","removeEventListener","normalizer","clearInterval","disconnect","soft","getComputedStyle","overscrollBehavior","scrollBehavior","setInterval","readyState","version","get"],"mappings":"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"}